package dr.evomodel.epidemiology.casetocase;

import dr.app.tools.NexusExporter;
import dr.evolution.coalescent.*;
import dr.evolution.tree.FlexibleNode;
import dr.evolution.tree.FlexibleTree;
import dr.evolution.tree.NodeRef;
import dr.evolution.tree.Tree;
import dr.evolution.util.Taxon;
import dr.evolution.util.TaxonList;
import dr.evomodel.coalescent.DemographicModel;
import dr.evomodel.tree.TreeModel;
import dr.inference.model.Model;
import dr.inference.model.Parameter;
import dr.inference.model.Variable;
import dr.math.*;
import dr.math.distributions.NormalGammaDistribution;
import dr.math.functionEval.GammaFunction;
import dr.xml.*;
import org.apache.commons.math.MathException;
import org.apache.commons.math.distribution.TDistributionImpl;

import java.io.IOException;
import java.io.PrintStream;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashSet;

/**
 * Intended to replace the tree prior; each partition is considered a tree in its own right generated by a
 * coalescent process
 *
 * @author Matthew Hall
 */

public class WithinCaseCoalescent extends CaseToCaseTreeLikelihood {

    public static final String WITHIN_CASE_COALESCENT = "withinCaseCoalescent";
    private Double[] partitionTreeLogLikelihoods;
    private Double[] storedPartitionTreeLogLikelihoods;
    private Double[] timingLogLikelihoods;
    private Double[] storedTimingLogLikelihoods;
    private TreePlusRootBranchLength[] partitionsAsTrees;
    private TreePlusRootBranchLength[] storedPartitionsAsTrees;
    private DemographicModel demoModel;
    private Parameter startingNe;


    public WithinCaseCoalescent(TreeModel virusTree, AbstractOutbreak caseData, String startingNetworkFileName,
                                Parameter infectionTimeBranchPositions, Parameter maxFirstInfToRoot,
                                DemographicModel demoModel, Parameter startingNe)
            throws TaxonList.MissingTaxonException {
        this(virusTree, caseData, startingNetworkFileName, infectionTimeBranchPositions, null,
                maxFirstInfToRoot, demoModel, startingNe);
    }

    public WithinCaseCoalescent(TreeModel virusTree, AbstractOutbreak caseData, String startingNetworkFileName,
                                Parameter infectionTimeBranchPositions, Parameter infectiousTimePositions,
                                Parameter maxFirstInfToRoot, DemographicModel demoModel, Parameter startingNe)
            throws TaxonList.MissingTaxonException {
        super(WITHIN_CASE_COALESCENT, virusTree, caseData, infectionTimeBranchPositions, infectiousTimePositions,
                maxFirstInfToRoot);
        this.demoModel = demoModel;
        addModel(demoModel);
        this.startingNe = startingNe;
        partitionTreeLogLikelihoods = new Double[noTips];
        storedPartitionTreeLogLikelihoods = new Double[noTips];
        timingLogLikelihoods = new Double[noTips];
        storedTimingLogLikelihoods = new Double[noTips];

        partitionsAsTrees = new TreePlusRootBranchLength[caseData.size()];
        storedPartitionsAsTrees = new TreePlusRootBranchLength[caseData.size()];

        prepareTree(startingNetworkFileName);

        prepareTimings();
    }

    public static double[] logOfAllValues(double[] values){
        double[] out = Arrays.copyOf(values, values.length);

        for(int i=0; i<values.length; i++){
            out[i] = Math.log(out[i]);
        }
        return out;
    }

    protected double calculateLogLikelihood(){

        // todo don't calculate this unless you have to

        double logL = 0;

        super.prepareTimings();

        int noInfectiousCategories = ((WithinCaseCategoryOutbreak)cases).getInfectiousCategoryCount();

        ArrayList<String> infectiousCategories = ((WithinCaseCategoryOutbreak)cases).getInfectiousCategories();

        ArrayList<ArrayList<Double>> infectiousPeriodsByCategory = new ArrayList<ArrayList<Double>>();

        for(int i=0; i<noInfectiousCategories; i++){
            infectiousPeriodsByCategory.add(new ArrayList<Double>());
        }

        for(AbstractCase aCase : cases.getCases()){
            String category = ((WithinCaseCategoryOutbreak)cases).getInfectiousCategory(aCase);

            ArrayList<Double> correspondingList
                    = infectiousPeriodsByCategory.get(infectiousCategories.indexOf(category));

            correspondingList.add(infectiousPeriods[cases.getCaseIndex(aCase)]);
        }

        for(int i=0; i<noInfectiousCategories; i++){
            ArrayList<Double> infPeriodsInThisCategory = infectiousPeriodsByCategory.get(i);

            double count = (double)infPeriodsInThisCategory.size();

            NormalGammaDistribution prior = ((WithinCaseCategoryOutbreak)cases)
                    .getInfectiousCategoryPrior(((WithinCaseCategoryOutbreak)cases).getInfectiousCategories().get(i));

            double[] infPredictiveDistributionParameters=prior.getParameters();

            double mu_0 = infPredictiveDistributionParameters[0];
            double lambda_0 = infPredictiveDistributionParameters[1];
            double alpha_0 = infPredictiveDistributionParameters[2];
            double beta_0 = infPredictiveDistributionParameters[3];

            double lambda_n = lambda_0 + count;
            double alpha_n = alpha_0 + count/2;
            double sum = 0;
            for (Double infPeriod : infPeriodsInThisCategory) {
                sum += infPeriod;
            }
            double mean = sum/count;

            double sumOfDifferences = 0;
            for (Double infPeriod : infPeriodsInThisCategory) {
                sumOfDifferences += Math.pow(infPeriod-mean,2);
            }

            double mu_n = (lambda_0*mu_0 + sum)/(lambda_0 + count);
            double beta_n = beta_0 + 0.5*sumOfDifferences + lambda_0*count*Math.pow(mean-mu_0, 2)/(2*(lambda_0+count));

            double priorPredictiveProbability
                    = GammaFunction.logGamma(alpha_n)
                    - GammaFunction.logGamma(alpha_0)
                    + alpha_0*Math.log(beta_0)
                    - alpha_n*Math.log(beta_n)
                    + 0.5*Math.log(lambda_0)
                    - 0.5*Math.log(lambda_n)
                    - (count/2)*Math.log(2*Math.PI);

            logL += priorPredictiveProbability;

            //todo log the parameters of the "posterior"
        }

        if(hasLatentPeriods){
            int noLatentCategories = ((WithinCaseCategoryOutbreak)cases).getLatentCategoryCount();

            ArrayList<String> latentCategories = ((WithinCaseCategoryOutbreak)cases).getLatentCategories();

            ArrayList<ArrayList<Double>> latentPeriodsByCategory = new ArrayList<ArrayList<Double>>();

            for(int i=0; i<noLatentCategories; i++){
                latentPeriodsByCategory.add(new ArrayList<Double>());
            }

            for(AbstractCase aCase : cases.getCases()){
                String category = ((WithinCaseCategoryOutbreak)cases).getLatentCategory(aCase);

                ArrayList<Double> correspondingList
                        = latentPeriodsByCategory.get(latentCategories.indexOf(category));

                correspondingList.add(latentPeriods[cases.getCaseIndex(aCase)]);
            }

            for(int i=0; i<noLatentCategories; i++){
                ArrayList<Double> latPeriodsInThisCategory = latentPeriodsByCategory.get(i);

                double count = (double)latPeriodsInThisCategory.size();

                NormalGammaDistribution prior = ((WithinCaseCategoryOutbreak)cases)
                        .getLatentCategoryPrior(((WithinCaseCategoryOutbreak) cases).getLatentCategories().get(i));

                double[] latPredictiveDistributionParameters=prior.getParameters();

                double mu_0 = latPredictiveDistributionParameters[0];
                double lambda_0 = latPredictiveDistributionParameters[1];
                double alpha_0 = latPredictiveDistributionParameters[2];
                double beta_0 = latPredictiveDistributionParameters[3];

                double lambda_n = lambda_0 + count;
                double alpha_n = alpha_0 + count/2;
                double sum = 0;
                for (Double latPeriod : latPeriodsInThisCategory) {
                    sum += latPeriod;
                }
                double mean = sum/count;

                double sumOfDifferences = 0;
                for (Double latPeriod : latPeriodsInThisCategory) {
                    sumOfDifferences += Math.pow(latPeriod-mean,2);
                }

                double mu_n = (lambda_0*mu_0 + sum)/(lambda_0 + count);
                double beta_n = beta_0 + 0.5*sumOfDifferences + lambda_0*count*Math.pow(mean-mu_0, 2)
                        /(2*(lambda_0+count));

                double priorPredictiveProbability
                        = GammaFunction.logGamma(alpha_n)
                        - GammaFunction.logGamma(alpha_0)
                        + alpha_0*Math.log(beta_0)
                        - alpha_n*Math.log(beta_n)
                        + 0.5*Math.log(lambda_0)
                        - 0.5*Math.log(lambda_n)
                        - (count/2)*Math.log(2*Math.PI);

                logL += priorPredictiveProbability;

                //todo log the parameters of the "posterior"
            }

        }

        explodeTree();

        // old version: if the prior on the TT structure is non-informative, then we can just use Cayley's formula with
        // an additional noTips multiplication for the choice of root:

        // double logL = -Math.log(Math.pow(noTips, noTips-1));

        // ArrayList<AbstractCase> caseOrdering = postOrderTransmissionTreeTraversal();

        // set up arrays

//
//
//        double[][][] infPredictiveDistributionParameters
//                = new double[noInfectiousCategories][getOutbreak().size()+1][4];
//
//        double[][][] latPredictiveDistributionParameters = hasLatentPeriods ?
//                new double[noLatentCategories][getOutbreak().size()+1][4] :  null;

//        for(int i=0; i<noInfectiousCategories; i++){
//            NormalGammaDistribution prior = ((WithinCaseCategoryOutbreak)cases)
//                    .getInfectiousCategoryPrior(((WithinCaseCategoryOutbreak)cases).getInfectiousCategories().get(i));
//
//            infPredictiveDistributionParameters[i][0]=prior.getParameters();
//        }
//
//        if(hasLatentPeriods){
//            for(int i=0; i<noLatentCategories; i++){
//                NormalGammaDistribution prior = ((WithinCaseCategoryOutbreak)cases)
//                        .getLatentCategoryPrior(((WithinCaseCategoryOutbreak) cases).getLatentCategories().get(i));
//
//                latPredictiveDistributionParameters[i][0]=prior.getParameters();
//            }
//        }
//
//        int[] infCounts = new int[noInfectiousCategories];
//        double[] infRunningSums = new double[noInfectiousCategories];
//
//        int[] latCounts = hasLatentPeriods ? new int[noLatentCategories] : null;
//        double[] latRunningSums = hasLatentPeriods ? new double[noLatentCategories] : null;

        for(AbstractCase aCase : cases.getCases()){

            //todo weights (and remember if a weight is zero then the return value should be -INF)

            int number = cases.getCaseIndex(aCase);

            if(timingLogLikelihoods[number]==null){
                double infectionTime = infectionTimes[number];
                int possibleParents = 0;
                for(int i=0; i<cases.size(); i++){
                    AbstractCase parentCandidate = cases.getCase(i);

                    if(i!=number && infectiousTimes[i]<infectionTime && !parentCandidate.culledYet(infectionTime)){
                        possibleParents++;
                    }
                }
                if(possibleParents>1){
                    timingLogLikelihoods[number] = Math.log(possibleParents);
                } else {
                    timingLogLikelihoods[number] = 0.0;
                }
            }

            logL += timingLogLikelihoods[number];


//
//
//                int intCategoryNo = ((WithinCaseCategoryOutbreak)cases).getInfectiousCategories()
//                        .indexOf(((WithinCaseCategoryOutbreak)cases).getInfectiousCategory(aCase));
//
//                int latCategoryNo = hasLatentPeriods ?
//                        ((WithinCaseCategoryOutbreak)cases).getLatentCategories()
//                                .indexOf(((WithinCaseCategoryOutbreak)cases).getLatentCategory(aCase)) : 0;
//
//                double cullTime = aCase.getCullTime();
//                double infectiousTime = getInfectiousTime(aCase);
//                double infectionTime = getInfectionTime(aCase);
//
//                double infectiousPeriod = cullTime - infectiousTime;
//                double latentPeriod = infectionTime - infectionTime;
//
//                double latestInfectiousTime = cullTime;
//
//                for(AbstractCase child : children){
//                    double childInfTime = getInfectionTime(child);
//                    if(childInfTime<latestInfectiousTime){
//                        latestInfectiousTime = childInfTime;
//                    }
//                }
//
//                double firstInfMu = infPredictiveDistributionParameters[intCategoryNo][0][0];
//                double firstInfLambda = infPredictiveDistributionParameters[intCategoryNo][0][1];
//
//                double currentInfMu = infPredictiveDistributionParameters[intCategoryNo][infCounts[intCategoryNo]][0];
//                double currentInfLambda = infPredictiveDistributionParameters[intCategoryNo][infCounts[intCategoryNo]][1];
//                double currentInfAlpha = infPredictiveDistributionParameters[intCategoryNo][infCounts[intCategoryNo]][2];
//                double currentInfBeta = infPredictiveDistributionParameters[intCategoryNo][infCounts[intCategoryNo]][3];
//
//                double firstLatMu = hasLatentPeriods ? latPredictiveDistributionParameters[intCategoryNo][0][0] : 0;
//                double firstLatLambda = hasLatentPeriods ? latPredictiveDistributionParameters[intCategoryNo][0][1] : 0;
//
//                double currentLatMu = hasLatentPeriods ?
//                        latPredictiveDistributionParameters[intCategoryNo][infCounts[intCategoryNo]][0] : 0;
//                double currentLatLambda = hasLatentPeriods ?
//                        infPredictiveDistributionParameters[intCategoryNo][infCounts[intCategoryNo]][1] : 0;
//                double currentLatAlpha = hasLatentPeriods ?
//                        infPredictiveDistributionParameters[intCategoryNo][infCounts[intCategoryNo]][2] : 0;
//                double currentLatBeta = hasLatentPeriods ?
//                        infPredictiveDistributionParameters[intCategoryNo][infCounts[intCategoryNo]][3] : 0;
//
//
//                if(parent!=null){
//                    double latestInfectionTime = parent.getCullTime();
//                    infRunningSums[intCategoryNo] += Math.log(infectiousPeriod);
//                    if(hasLatentPeriods){
//                        latRunningSums[latCategoryNo] += Math.log(latentPeriod);
//                    }
//                    double minimumInfectiousPeriod = hasLatentPeriods
//                            ? Math.min(cullTime - latestInfectiousTime,0) : Math.min(cullTime - latestInfectionTime,0);
//                    if(infectiousPeriod < minimumInfectiousPeriod){
//                        timingLogLikelihoods[number]=Double.NEGATIVE_INFINITY;
//                    } else {
//                        double sigma = Math.sqrt(currentInfBeta*(currentInfLambda+1)/(currentInfAlpha*currentInfLambda));
//                        double probability = tDistributionPDF(
//                                Math.log(infectiousPeriod),currentInfMu,sigma,2*currentInfAlpha);
//                        double normalisation = 1;
//                        if(minimumInfectiousPeriod>0){
//                            try{
//                                normalisation = 1-tDistributionCDF(Math.log(minimumInfectiousPeriod),currentInfMu,sigma,
//                                        2*currentInfAlpha);
//                            } catch(MathException e){
//                                throw new RuntimeException("t-distribution CDF calculation failed");
//                                // (or return zero likelihood?)
//                            }
//                        }
//                        timingLogLikelihoods[number] = Math.log(probability)-Math.log(normalisation);
//                    }
//
//                    if(hasLatentPeriods){
//                        double minimumLatentPeriod = Math.min(infectiousTime - latestInfectionTime, 0);
//
//                        if(latentPeriod < minimumLatentPeriod){
//                            timingLogLikelihoods[number]=Double.NEGATIVE_INFINITY;
//                        } else {
//
//
//                            double sigma = Math.sqrt(currentLatBeta*(currentLatLambda+1)/(currentLatAlpha*currentLatLambda));
//                            double probability = tDistributionPDF(
//                                    Math.log(latentPeriod),currentLatMu,sigma,2*currentLatAlpha);
//                            double normalisation = 1;
//                            if(minimumLatentPeriod>0){
//                                try{
//                                    normalisation = 1-tDistributionCDF(Math.log(minimumLatentPeriod),currentLatMu,sigma,
//                                            2*currentLatAlpha);
//                                } catch (MathException e){
//                                    throw new RuntimeException("t-distribution CDF calculation failed");
//                                    // (or return zero likelihood?)
//                                }
//                            }
//                            timingLogLikelihoods[number]
//                                    += Math.log(probability)-Math.log(normalisation);
//                        }
//                    }
//
//                    int n = infCounts[intCategoryNo]++;
//                    double newInfMu = (firstInfLambda*firstInfMu + infRunningSums[intCategoryNo])/(firstInfLambda + n);
//                    double newInfLambda = currentInfLambda + 1;
//                    double newInfAlpha = currentInfAlpha + 0.5;
//
//                    double mean = infRunningSums[intCategoryNo]/n;
//
//                    double newInfBeta = infPredictiveDistributionParameters[intCategoryNo][infCounts[intCategoryNo]-1][3]
//                            +0.5*Math.pow(Math.log(infectiousPeriod)-mean,2)
//                            +currentInfLambda*Math.pow(mean-currentInfMu,2)/(2*(currentInfLambda+1));
//
//                    infPredictiveDistributionParameters[intCategoryNo][infCounts[intCategoryNo]] =
//                            new double[]{newInfMu, newInfLambda, newInfAlpha, newInfBeta};
//
//                    if(hasLatentPeriods){
//                        n = latCounts[intCategoryNo]++;
//                        double newLatMu = (firstLatLambda*firstLatMu + latRunningSums[latCategoryNo])/(firstLatLambda + n);
//                        double newLatLambda = currentLatLambda + 1;
//                        double newLatAlpha = currentLatAlpha + 0.5;
//
//                        mean = latRunningSums[latCategoryNo]/n;
//
//                        double newLatBeta
//                                = latPredictiveDistributionParameters[latCategoryNo][latCounts[latCategoryNo]-1][3]
//                                +0.5*Math.pow(Math.log(latentPeriod)-mean,2)
//                                +currentLatLambda*Math.pow(mean-currentLatMu,2)/(2*(currentLatLambda+1));
//
//                        latPredictiveDistributionParameters[latCategoryNo][infCounts[intCategoryNo]] =
//                                new double[]{newLatMu, newLatLambda, newLatAlpha, newLatBeta};
//
//                    }
//
//                }




            // and then the little tree calculations

            HashSet<AbstractCase> children = getInfectees(aCase);

            if(timingLogLikelihoods[number]!=null){
                AbstractCase parent = getInfector(aCase);
            }

            if(partitionTreeLogLikelihoods[number]==null){
                TreePlusRootBranchLength treelet = partitionsAsTrees[number];

                if(DEBUG && treelet.getNodeCount()>1){
                    debugTreelet(treelet, aCase+"_partition.nex");
                }

                if(children.size()!=0){
                    MaxTMRCACoalescent coalescent = new MaxTMRCACoalescent(treelet, demoModel,
                            treelet.getRootHeight()+treelet.getRootBranchLength());
                    partitionTreeLogLikelihoods[number] = coalescent.calculateLogLikelihood();
                    logL += partitionTreeLogLikelihoods[number];
                    if(partitionTreeLogLikelihoods[number]==Double.POSITIVE_INFINITY && DEBUG){
                        debugOutputTree("infCoalescent.nex", false);
                    }
                } else {
                    partitionTreeLogLikelihoods[number] = 0.0;
                }
            } else {
                logL += partitionTreeLogLikelihoods[number];
            }
        }
        likelihoodKnown = true;

        if(DEBUG){
            debugOutputTree("out.nex", true);
        }

        return logL;


    }

    private double tDistributionPDF(double x, double mu, double sigma, double df){
        TDistributionImpl distribution = new TDistributionImpl(df);
        return distribution.density((x-mu)/sigma);
    }

    private double tDistributionCDF(double x, double mu, double sigma, double df) throws MathException{
        TDistributionImpl distribution = new TDistributionImpl(df);
        return distribution.cumulativeProbability((x-mu)/sigma);
    }

    public void storeState(){
        super.storeState();
        storedPartitionsAsTrees = Arrays.copyOf(partitionsAsTrees, partitionsAsTrees.length);
        storedPartitionTreeLogLikelihoods = Arrays.copyOf(storedPartitionTreeLogLikelihoods,
                storedPartitionTreeLogLikelihoods.length);
        storedTimingLogLikelihoods = Arrays.copyOf(timingLogLikelihoods, timingLogLikelihoods.length);
    }

    public void restoreState(){
        super.restoreState();
        partitionsAsTrees = storedPartitionsAsTrees;
        partitionTreeLogLikelihoods = storedPartitionTreeLogLikelihoods;
        timingLogLikelihoods = storedTimingLogLikelihoods;
    }

    protected void handleModelChangedEvent(Model model, Object object, int index) {

        // todo this is obviously wasteful at the moment

        super.handleModelChangedEvent(model, object, index);

        if(model == treeModel || model == demoModel || model==branchMap){
            Arrays.fill(partitionTreeLogLikelihoods, null);
            Arrays.fill(partitionsAsTrees, null);
        }
        Arrays.fill(timingLogLikelihoods, null);
    }

    protected void handleVariableChangedEvent(Variable variable, int index, Parameter.ChangeType type) {


        // todo this too is obviously wasteful at the moment

        super.handleVariableChangedEvent(variable, index, type);

        if(variable == infectionTimeBranchPositions || variable == infectiousTimePositions){
            Arrays.fill(partitionTreeLogLikelihoods, null);
            Arrays.fill(partitionsAsTrees, null);
            Arrays.fill(timingLogLikelihoods, null);
        }
    }

    public void makeDirty(){
        super.makeDirty();
        Arrays.fill(partitionTreeLogLikelihoods, null);
        Arrays.fill(timingLogLikelihoods, null);
        Arrays.fill(partitionsAsTrees, null);

    }

    // Tears the tree into small pieces. Indexes correspond to indexes in the outbreak.
    // todo Work out when components of this are unchanged after PT or TT moves

    private void explodeTree(){
        if(DEBUG){
            debugOutputTree("test.nex", false);
        }
        for(int i=0; i<cases.size(); i++){
            if(partitionsAsTrees[i]==null){
                AbstractCase aCase = cases.getCase(i);

                NodeRef partitionRoot = getEarliestNodeInPartition(aCase);

                double infectionTime = getInfectionTime(branchMap.get(partitionRoot.getNumber()));
                double rootTime = getNodeTime(partitionRoot);

                FlexibleNode newRoot = new FlexibleNode();

                FlexibleTree littleTree = new FlexibleTree(newRoot);
                littleTree.beginTreeEdit();

                if(!treeModel.isExternal(partitionRoot)){
                    for(int j=0; j<treeModel.getChildCount(partitionRoot); j++){
                        copyPartitionToLittleTree(littleTree, treeModel.getChild(partitionRoot, j), newRoot, aCase);
                    }
                }

                littleTree.endTreeEdit();

                littleTree.resolveTree();

                partitionsAsTrees[i] = new TreePlusRootBranchLength(littleTree, rootTime - infectionTime);
            }
        }
    }

    public ArrayList<AbstractCase> postOrderTransmissionTreeTraversal(){
        return traverseTransmissionTree(branchMap.get(treeModel.getRoot().getNumber()));
    }

    private ArrayList<AbstractCase> traverseTransmissionTree(AbstractCase aCase){
        ArrayList<AbstractCase> out = new ArrayList<AbstractCase>();
        HashSet<AbstractCase> children = getInfectees(aCase);
        for(int i=0; i<getOutbreak().size(); i++){
            AbstractCase possibleChild = getOutbreak().getCase(i);
            // easiest way to maintain the set ordering of the cases?
            if(children.contains(possibleChild)){
                out.addAll(traverseTransmissionTree(possibleChild));
            }
        }
        out.add(aCase);
        return out;
    }

    private void copyPartitionToLittleTree(FlexibleTree littleTree, NodeRef oldNode, NodeRef newParent,
                                           AbstractCase partition){
        if(branchMap.get(oldNode.getNumber())==partition){
            if(treeModel.isExternal(oldNode)){
                NodeRef newTip = new FlexibleNode(new Taxon(treeModel.getNodeTaxon(oldNode).getId()));
                littleTree.addChild(newParent, newTip);
                littleTree.setBranchLength(newTip, treeModel.getBranchLength(oldNode));
            } else {
                NodeRef newChild = new FlexibleNode();
                littleTree.addChild(newParent, newChild);
                littleTree.setBranchLength(newChild, treeModel.getBranchLength(oldNode));
                for(int i=0; i<treeModel.getChildCount(oldNode); i++){
                    copyPartitionToLittleTree(littleTree, treeModel.getChild(oldNode, i), newChild, partition);
                }
            }
        } else {
            // we need a new tip
            NodeRef transmissionTip = new FlexibleNode(
                    new Taxon("Transmission_"+branchMap.get(oldNode.getNumber()).caseID));
            double parentTime = getNodeTime(treeModel.getParent(oldNode));
            double childTime = getInfectionTime(branchMap.get(oldNode.getNumber()));
            littleTree.addChild(newParent, transmissionTip);
            littleTree.setBranchLength(transmissionTip, childTime - parentTime);

        }
    }

    private class TreePlusRootBranchLength extends FlexibleTree {

        private double rootBranchLength;

        private TreePlusRootBranchLength(FlexibleTree tree, double rootBranchLength){
            super(tree);
            this.rootBranchLength = rootBranchLength;
        }

        private double getRootBranchLength(){
            return rootBranchLength;
        }

        private void setRootBranchLength(double rootBranchLength){
            this.rootBranchLength = rootBranchLength;
        }
    }

    private class MaxTMRCACoalescent extends Coalescent {

        private double maxHeight;

        private MaxTMRCACoalescent(Tree tree, DemographicModel demographicModel, double maxHeight){
            super(tree, demographicModel.getDemographicFunction());
            ConstantPopulation demFunct = (ConstantPopulation)demographicModel.getDemographicFunction();

            if(demographicModel instanceof LogisticGrowthN0N50Model){

                demFunct.setArgument(2, maxHeight);

            } else {

            // want to set this so the population size is 1 at the point of infection

                double oldN0 = demFunct.getN0();
                double growthTerm = demFunct.getDemographic(maxHeight)/oldN0;
                demFunct.setN0(startingNe.getParameterValue(0)/growthTerm);

            }

            this.maxHeight = maxHeight;

        }

        public double calculateLogLikelihood() {
            return calculatePartitionTreeLogLikelihood(getIntervals(), getDemographicFunction(), 0, maxHeight);
        }

    }

    public static double calculatePartitionTreeLogLikelihood(IntervalList intervals,
                                                             DemographicFunction demographicFunction, double threshold,
                                                             double maxHeight) {

        double logL = 0.0;

        double startTime = 0.0;
        final int n = intervals.getIntervalCount();

        //TreeIntervals sets up a first zero-length interval with a lineage count of zero - skip this one

        for (int i = 0; i < n; i++) {

            final double duration = intervals.getInterval(i);
            final double finishTime = startTime + duration;

            final double intervalArea = demographicFunction.getIntegral(startTime, finishTime);
            double normalisationArea = demographicFunction.getIntegral(startTime, maxHeight);

            if( intervalArea == 0 && duration != 0 ) {
                return Double.NEGATIVE_INFINITY;
            }
            final int lineageCount = intervals.getLineageCount(i);

            if(lineageCount>=2){

                final double kChoose2 = Binomial.choose2(lineageCount);

                if (intervals.getIntervalType(i) == IntervalType.COALESCENT) {

                    logL += -kChoose2 * intervalArea;

                    final double demographicAtCoalPoint = demographicFunction.getDemographic(finishTime);

                    if( duration == 0.0 || demographicAtCoalPoint * (intervalArea/duration) >= threshold ) {
                        logL -= Math.log(demographicAtCoalPoint);
                    } else {
                        return Double.NEGATIVE_INFINITY;
                    }

                } else {
                    double numerator = Math.exp(-kChoose2 * intervalArea) - Math.exp(-kChoose2 * normalisationArea);
                    logL += Math.log(numerator);

                }

                // normalisation

                // double denominator = 1-Math.exp(-kChoose2 * normalisationArea);

                logL -= Math.log1p(-Math.exp(-kChoose2 * normalisationArea));

            }

            startTime = finishTime;
        }

        return logL;
    }

    public void debugTreelet(Tree treelet, String fileName){
        try{
            FlexibleTree treeCopy = new FlexibleTree(treelet);
            for(int j=0; j<treeCopy.getNodeCount(); j++){
                FlexibleNode node = (FlexibleNode)treeCopy.getNode(j);
                node.setAttribute("Number", node.getNumber());
            }
            NexusExporter testTreesOut = new NexusExporter(new PrintStream(fileName));
            testTreesOut.exportTree(treeCopy);
        } catch (IOException ignored) {System.out.println("IOException");}
    }


    //************************************************************************
    // AbstractXMLObjectParser implementation
    //************************************************************************

    public static XMLObjectParser PARSER = new AbstractXMLObjectParser() {
        public static final String STARTING_NETWORK = "startingNetwork";
        public static final String INFECTION_TIMES = "infectionTimeBranchPositions";
        public static final String INFECTIOUS_TIMES = "infectiousTimePositions";
        public static final String MAX_FIRST_INF_TO_ROOT = "maxFirstInfToRoot";
        public static final String DEMOGRAPHIC_MODEL = "demographicModel";
        public static final String STARTING_NE = "startingNe";

        public String getParserName() {
            return WITHIN_CASE_COALESCENT;
        }

        public Object parseXMLObject(XMLObject xo) throws XMLParseException {

            TreeModel virusTree = (TreeModel) xo.getChild(TreeModel.class);

            String startingNetworkFileName=null;

            if(xo.hasChildNamed(STARTING_NETWORK)){
                startingNetworkFileName = (String) xo.getElementFirstChild(STARTING_NETWORK);
            }

            AbstractOutbreak caseSet = (AbstractOutbreak) xo.getChild(AbstractOutbreak.class);

            CaseToCaseTreeLikelihood likelihood;

            Parameter infectionTimes = (Parameter) xo.getElementFirstChild(INFECTION_TIMES);

            Parameter infectiousTimes = xo.hasChildNamed(INFECTIOUS_TIMES)
                    ? (Parameter) xo.getElementFirstChild(INFECTIOUS_TIMES) : null;

            Parameter earliestFirstInfection = (Parameter) xo.getElementFirstChild(MAX_FIRST_INF_TO_ROOT);

            Parameter startingNe = (Parameter) xo.getElementFirstChild(STARTING_NE);

            DemographicModel demoModel = (DemographicModel) xo.getElementFirstChild(DEMOGRAPHIC_MODEL);

            try {
                likelihood = new WithinCaseCoalescent(virusTree, caseSet, startingNetworkFileName, infectionTimes,
                        infectiousTimes, earliestFirstInfection, demoModel, startingNe);
            } catch (TaxonList.MissingTaxonException e) {
                throw new XMLParseException(e.toString());
            }

            return likelihood;
        }

        public String getParserDescription() {
            return "This element provides a tree prior for a partitioned tree, with each partitioned tree generated" +
                    "by a coalescent process";
        }

        public Class getReturnType() {
            return WithinCaseCoalescent.class;
        }

        public XMLSyntaxRule[] getSyntaxRules() {
            return rules;
        }

        private final XMLSyntaxRule[] rules = {
                new ElementRule(TreeModel.class, "The tree"),
                new ElementRule(WithinCaseCategoryOutbreak.class, "The set of cases"),
                new ElementRule("startingNetwork", String.class, "A CSV file containing a specified starting network",
                        true),
                new ElementRule(MAX_FIRST_INF_TO_ROOT, Parameter.class, "The maximum time from the first infection to" +
                        "the root node"),
                new ElementRule(INFECTION_TIMES, Parameter.class),
                new ElementRule(INFECTIOUS_TIMES, Parameter.class, "For each case, proportions of the time between " +
                        "infection and first event that requires infectiousness (further infection or cull)" +
                        "that has elapsed before infectiousness", true),
                new ElementRule(DEMOGRAPHIC_MODEL, DemographicModel.class, "The demographic model for within-case" +
                        "evolution"),
                new ElementRule(STARTING_NE, Parameter.class, "The effective population size in a given case at the " +
                        "point of infection")
        };
    };
}
