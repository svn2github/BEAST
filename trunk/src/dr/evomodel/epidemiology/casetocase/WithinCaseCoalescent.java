package dr.evomodel.epidemiology.casetocase;

import dr.evolution.coalescent.Coalescent;
import dr.evolution.coalescent.DemographicFunction;
import dr.evolution.coalescent.IntervalList;
import dr.evolution.coalescent.IntervalType;
import dr.evolution.tree.FlexibleNode;
import dr.evolution.tree.FlexibleTree;
import dr.evolution.tree.NodeRef;
import dr.evolution.tree.Tree;
import dr.evolution.util.Taxon;
import dr.evolution.util.TaxonList;
import dr.evomodel.tree.TreeModel;
import dr.inference.model.Parameter;
import dr.math.Binomial;

import java.util.HashSet;

/**
 * Intended to replace the tree prior; each partition is considered a tree in its own right generated by a
 * coalescent process
 *
 * @author Matthew Hall
 */

public class WithinCaseCoalescent extends CaseToCaseTreeLikelihood {

    public static final String WITHIN_CASE_COALSECENT = "withinCaseCoalescent";
    private TreePlusRootBranchLength[] partitionsAsTrees;
    private TreePlusRootBranchLength[] storedPartitionsAsTrees;
    private DemographicFunction demoFunct;

    public WithinCaseCoalescent(TreeModel virusTree, AbstractOutbreak caseData, String startingNetworkFileName,
                                    Parameter infectionTimeBranchPositions, Parameter maxFirstInfToRoot,
                                    boolean extended, boolean normalise, boolean jeffreys)
            throws TaxonList.MissingTaxonException {
        super(WITHIN_CASE_COALSECENT, virusTree, caseData, startingNetworkFileName, infectionTimeBranchPositions, null,
                maxFirstInfToRoot, extended, normalise, jeffreys);
    }


    public static double calculatePartitionLogLikelihood(IntervalList intervals,
                                                         DemographicFunction demographicFunction, double threshold,
                                                         double maxHeight) {

        double logL = 0.0;

        double startTime = 0.0;
        final int n = intervals.getIntervalCount();
        for (int i = 0; i < n; i++) {

            final double duration = intervals.getInterval(i);
            final double finishTime = startTime + duration;

            final double intervalArea = demographicFunction.getIntegral(startTime, finishTime);
            double normalisationArea = demographicFunction.getIntegral(startTime, maxHeight);

            if( intervalArea == 0 && duration != 0 ) {
                return Double.NEGATIVE_INFINITY;
            }
            final int lineageCount = intervals.getLineageCount(i);

            final double kChoose2 = Binomial.choose2(lineageCount);

            if (intervals.getIntervalType(i) == IntervalType.COALESCENT) {

                logL += -kChoose2 * intervalArea;

                final double demographicAtCoalPoint = demographicFunction.getDemographic(finishTime);

                // if value at end is many orders of magnitude different than mean over interval reject the interval
                // This is protection against cases where ridiculous infitisimal
                // population size at the end of a linear interval drive coalescent values to infinity.

                if( duration == 0.0 || demographicAtCoalPoint * (intervalArea/duration) >= threshold ) {
                    logL -= Math.log(demographicAtCoalPoint);
                } else {
                    // remove this at some stage
                    return Double.NEGATIVE_INFINITY;
                }

            } else {
                double numerator = Math.exp(kChoose2 * intervalArea) - Math.exp(kChoose2 * normalisationArea);
                logL += Math.log(numerator);

            }

            // normalisation

            double denominator = 1-Math.exp(kChoose2 * normalisationArea);

            logL -= Math.log(denominator);

            startTime = finishTime;
        }

        return logL;
    }

    // Tears the tree into small pieces. Indexes correspond to indexes in the outbreak.
    // todo Work out when components of this are unchanged after PT or TT moves

    private void explodeTree(){
        for(int i=0; i<cases.size(); i++){
            AbstractCase aCase = cases.getCase(i);
            HashSet<NodeRef> caseNodes = extractNodes(treeModel.getRoot(), aCase);

            NodeRef partitionRoot = getEarliestNodeInPartition(aCase);

            double infectionTime = getInfectionTime(branchMap[partitionRoot.getNumber()]);
            double rootTime = getNodeTime(partitionRoot);

            FlexibleNode newRoot = new FlexibleNode();

            FlexibleTree littleTree = new FlexibleTree(newRoot);

            if(!treeModel.isExternal(partitionRoot)){
                for(int j=0; j<treeModel.getChildCount(partitionRoot); j++){
                    copyPartitionToTree(littleTree, treeModel.getChild(partitionRoot, j), newRoot, aCase);
                }
            }

            partitionsAsTrees[i] = new TreePlusRootBranchLength(littleTree, rootTime - infectionTime);
        }
    }

    private void copyPartitionToTree(FlexibleTree littleTree, NodeRef oldNode, NodeRef newParent,
                                        AbstractCase partition){
        if(branchMap[oldNode.getNumber()]==partition){
            if(treeModel.isExternal(oldNode)){
                NodeRef newTip = new FlexibleNode(new Taxon(treeModel.getNodeTaxon(oldNode).getId()));
                littleTree.addChild(newParent, newTip);
                littleTree.setBranchLength(newTip, treeModel.getBranchLength(oldNode));
            } else {
                NodeRef newChild = new FlexibleNode();
                littleTree.addChild(newParent, newChild);
                littleTree.setBranchLength(newChild, treeModel.getBranchLength(oldNode));
                for(int i=0; i<treeModel.getChildCount(oldNode); i++){
                    copyPartitionToTree(littleTree, treeModel.getChild(oldNode, i), newChild, partition);
                }
            }
        } else {
            // we need a new tip
            NodeRef transmissionTip = new FlexibleNode(
                    new Taxon("Transmission_"+branchMap[oldNode.getNumber()].caseID));
            double parentTime = getNodeTime(treeModel.getParent(oldNode));
            double childTime = getInfectionTime(branchMap[oldNode.getNumber()]);
            littleTree.addChild(newParent, transmissionTip);
            littleTree.setBranchLength(transmissionTip, childTime - parentTime);

        }
    }


    private HashSet<NodeRef> extractNodes(NodeRef earliestNode, AbstractCase partition){
        HashSet<NodeRef> out = new HashSet<NodeRef>();
        if(branchMap[earliestNode.getNumber()]==partition){
            out.add(earliestNode);
        }
        if(!treeModel.isExternal(earliestNode)){
            for(int i=0; i<treeModel.getChildCount(earliestNode); i++){
                out.addAll(extractNodes(treeModel.getChild(earliestNode, i), partition));
            }
        }
        return out;
    }



    private class MaxTMRCACoalescent extends Coalescent{

        private double maxHeight;

        private MaxTMRCACoalescent(Tree tree, DemographicFunction demographicFunction, double maxHeight){
            super(tree, demographicFunction);
            this.maxHeight = maxHeight;
        }

        public double calculateLogLikelihood() {
            return calculatePartitionLogLikelihood(getIntervals(), getDemographicFunction(), 0, maxHeight);
        }

    }

    private class TreePlusRootBranchLength extends FlexibleTree {

        private double rootBranchLength;

        private TreePlusRootBranchLength(FlexibleTree tree, double rootBranchLength){
            super(tree);
            this.rootBranchLength = rootBranchLength;
        }

        private double getRootBranchLength(){
            return rootBranchLength;
        }

        private void setRootBranchLength(){
            this.rootBranchLength = rootBranchLength;
        }
    }




}
